<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      关于Spring IOC容器和Spring MVC IOC容器以及同一个Bean多次实例化的一个问题（这标题真他喵长） | HQ&#39;s Cabin 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="HQ">
    
    

    <meta name="description" content="一、发现的问题好吧，这次是我接手的另外一个项目，不过这一次没有之前的那么坑了，因为这个只有一个架子在。。。也就是基本上只有一个pom.xml和web.xml和最基本的spring的配置文件，连数据库的表都还没建，不过这也好，至少不会被坑了（我以为。。）。 哈哈哈哈，我还是被坑了，他喵的连最基本的配置文件里也有坑。。。你是竞争对手派过来的卧底吗？ 嗯嗯，具体的问题就是： 之前的一直用Quartz来做">
<meta name="keywords" content="错误记录">
<meta property="og:type" content="article">
<meta property="og:title" content="关于Spring IOC容器和Spring MVC IOC容器以及同一个Bean多次实例化的一个问题（这标题真他喵长） | HQ&#39;s Cabin">
<meta property="og:url" content="http://yoursite.com/2017/08/04/关于Spring IOC容器和Spring MVC IOC容器以及同一个Bean多次实例化的一个问题（这标题真他喵长） - 副本/index.html">
<meta property="og:site_name" content="HQ&#39;s Cabin">
<meta property="og:description" content="一、发现的问题好吧，这次是我接手的另外一个项目，不过这一次没有之前的那么坑了，因为这个只有一个架子在。。。也就是基本上只有一个pom.xml和web.xml和最基本的spring的配置文件，连数据库的表都还没建，不过这也好，至少不会被坑了（我以为。。）。 哈哈哈哈，我还是被坑了，他喵的连最基本的配置文件里也有坑。。。你是竞争对手派过来的卧底吗？ 嗯嗯，具体的问题就是： 之前的一直用Quartz来做">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20170804213800.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20170804222429.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/3.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/4.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/5.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/6.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/7.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/8.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/9.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/10.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/11.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/12.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/13.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/14.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/15.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/16.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/17.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/18.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/19.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/20.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/21.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/22.png">
<meta property="og:image" content="http://ou5y7q62a.bkt.clouddn.com/23.png">
<meta property="og:updated_time" content="2018-08-18T21:36:26.898Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于Spring IOC容器和Spring MVC IOC容器以及同一个Bean多次实例化的一个问题（这标题真他喵长） | HQ&#39;s Cabin">
<meta name="twitter:description" content="一、发现的问题好吧，这次是我接手的另外一个项目，不过这一次没有之前的那么坑了，因为这个只有一个架子在。。。也就是基本上只有一个pom.xml和web.xml和最基本的spring的配置文件，连数据库的表都还没建，不过这也好，至少不会被坑了（我以为。。）。 哈哈哈哈，我还是被坑了，他喵的连最基本的配置文件里也有坑。。。你是竞争对手派过来的卧底吗？ 嗯嗯，具体的问题就是： 之前的一直用Quartz来做">
<meta name="twitter:image" content="http://ou5y7q62a.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20170804213800.png">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        
        <a href="/" title="link to homepage for HQ&#39;s Cabin"><img src="/avatar.png" width="80" alt="HQ&#39;s Cabin logo" class="panel-cover__logo logo"></a>
        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">HQ&#39;s Cabin</a></h1>
        <hr class="panel-cover__divider">

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">笔记</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              
                
                <li class="navigation__item"><a href="/eggs" title="" class="">其他</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
      <!-- Github -->
      <li class="navigation__item">
        <a href="https://github.com/KL3Answer" title="Huno on GitHub">
          <i class="icon icon-social-github"></i>
          <span class="label">GitHub</span>
        </a>
      </li>
    

    <!-- China social icon -->
    <!--
    
      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>

    -->



  </ul>
</nav>



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">关于Spring IOC容器和Spring MVC IOC容器以及同一个Bean多次实例化的一个问题（这标题真他喵长）</h1>

    

    <div class="post-meta">
      <time datetime="2017-08-04" class="post-meta__date date">2017-08-04</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/错误记录/">错误记录</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="一、发现的问题"><a href="#一、发现的问题" class="headerlink" title="一、发现的问题"></a>一、发现的问题</h3><p>好吧，这次是我接手的另外一个项目，不过这一次没有之前的那么坑了，因为这个只有一个架子在。。。<br>也就是基本上只有一个pom.xml和web.xml和最基本的spring的配置文件，连数据库的表都还没建，不过这也好，至少不会被坑了（我以为。。）。</p>
<p>哈哈哈哈，我还是被坑了，他喵的连最基本的配置文件里也有坑。。。你是竞争对手派过来的卧底吗？</p>
<p>嗯嗯，具体的问题就是：</p>
<p>之前的一直用Quartz来做定时服务，近几天我用了Spring的@Scheduled来写一个情况比较简单的定时服务(用Quartz就得写一堆xml文件，麻烦死了。。)，<br>结果发现定时服务的执行逻辑和我预想的逻辑不一致，更具体来说，就是我的定时服务先把一个表的数据清空，然后插入新的数据，而且是一次定时只执行一次,并且是串行化的。但是我查看数据库却发现存在重复数据，同一条数据会存在两条完全相同的记录。</p>
<h3 id="二、分析过程"><a href="#二、分析过程" class="headerlink" title="二、分析过程"></a>二、分析过程</h3><p>看了一下服务器的日志，没有异常信息，而且打断点调试之后发现每一次删除表的数据都是成功的，也就是说，重复的数据不是旧的数据，而是每一次定时都被执行了两次。</p>
<p>这样看来，应该是@Scheduled注解上面出了问题，那我们来看一下Spring对这个注解做了什么。</p>
<p>首先，我们来看一下@Scheduled注解：<br><img src="http://ou5y7q62a.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20170804213800.png" alt=""><br>可见，@Scheduled是被ScheduledAnnotationBeanPostProcessor注册的，而且是由@EnableScheduling注解指引自动注册的，我们接着看一下@EnableScheduling注解是怎么回事：</p>
<p><img src="http://ou5y7q62a.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20170804222429.png" alt=""><br>注意图中的这一句话：</p>
<blockquote>
<p>* This enables detection of @{@link Scheduled} annotations on any Spring-managed<br><br>* bean in the container.  For example, given a class {@code MyTask}</p>
</blockquote>
<p>也就是说你在注入Spring IOC容器的Bean上面加上@EnableScheduling，那么这个Bean里面的被@Scheduled注解的方法就会被扫描(不过上图也说了，你也可以在Configuration classses上面加这个注解，效果应该差不多？)</p>
<p>好的，那就是说，定时任务所在类被@EnableScheduling注解之后，并且在定时任务方法上加上@Scheduled注解，那么Spring IOC容器在初始化的时候就会调用ScheduledAnnotationBeanPostProcessor来注册定时任务了。</p>
<p>现在我们来看一下ScheduledAnnotationBeanPostProcessor到底干了什么<br><img src="http://ou5y7q62a.bkt.clouddn.com/3.png" alt=""><br>上面这个是它的描述，可知在Spring扫描到@EnableScheduling之后会注册一个ScheduledAnnotationBeanPostProcessor,通过断点，我们可以知道这个类中的关键方法是这个：<br><img src="http://ou5y7q62a.bkt.clouddn.com/4.png" alt=""><br>这个方法使用反射获取被@Scheduled注解的方法，并对这个方法如下调用：(因为太长了截不了图)</p>
<pre><code>protected void processScheduled(Scheduled scheduled, Method method, Object bean) {
    try {
        Assert.isTrue(void.class.equals(method.getReturnType()),
                &quot;Only void-returning methods may be annotated with @Scheduled&quot;);
        Assert.isTrue(method.getParameterTypes().length == 0,
                &quot;Only no-arg methods may be annotated with @Scheduled&quot;);

        if (AopUtils.isJdkDynamicProxy(bean)) {
            try {
                // Found a @Scheduled method on the target class for this JDK proxy -&gt;
                // is it also present on the proxy itself?
                method = bean.getClass().getMethod(method.getName(), method.getParameterTypes());
            }
            catch (SecurityException ex) {
                ReflectionUtils.handleReflectionException(ex);
            }
            catch (NoSuchMethodException ex) {
                throw new IllegalStateException(String.format(
                        &quot;@Scheduled method &apos;%s&apos; found on bean target class &apos;%s&apos;, &quot; +
                        &quot;but not found in any interface(s) for bean JDK proxy. Either &quot; +
                        &quot;pull the method up to an interface or switch to subclass (CGLIB) &quot; +
                        &quot;proxies by setting proxy-target-class/proxyTargetClass &quot; +
                        &quot;attribute to &apos;true&apos;&quot;, method.getName(), method.getDeclaringClass().getSimpleName()));
            }
        }

        Runnable runnable = new ScheduledMethodRunnable(bean, method);
        boolean processedSchedule = false;
        String errorMessage = &quot;Exactly one of the &apos;cron&apos;, &apos;fixedDelay(String)&apos;, or &apos;fixedRate(String)&apos; attributes is required&quot;;

        // Determine initial delay
        long initialDelay = scheduled.initialDelay();
        String initialDelayString = scheduled.initialDelayString();
        if (StringUtils.hasText(initialDelayString)) {
            Assert.isTrue(initialDelay &lt; 0, &quot;Specify &apos;initialDelay&apos; or &apos;initialDelayString&apos;, not both&quot;);
            if (this.embeddedValueResolver != null) {
                initialDelayString = this.embeddedValueResolver.resolveStringValue(initialDelayString);
            }
            try {
                initialDelay = Integer.parseInt(initialDelayString);
            }
            catch (NumberFormatException ex) {
                throw new IllegalArgumentException(
                        &quot;Invalid initialDelayString value \&quot;&quot; + initialDelayString + &quot;\&quot; - cannot parse into integer&quot;);
            }
        }

        // Check cron expression
        String cron = scheduled.cron();
        if (StringUtils.hasText(cron)) {
            Assert.isTrue(initialDelay == -1, &quot;&apos;initialDelay&apos; not supported for cron triggers&quot;);
            processedSchedule = true;
            String zone = scheduled.zone();
            if (this.embeddedValueResolver != null) {
                cron = this.embeddedValueResolver.resolveStringValue(cron);
                zone = this.embeddedValueResolver.resolveStringValue(zone);
            }
            TimeZone timeZone;
            if (StringUtils.hasText(zone)) {
                timeZone = StringUtils.parseTimeZoneString(zone);
            }
            else {
                timeZone = TimeZone.getDefault();
            }
            this.registrar.addCronTask(new CronTask(runnable, new CronTrigger(cron, timeZone)));
        }

        // At this point we don&apos;t need to differentiate between initial delay set or not anymore
        if (initialDelay &lt; 0) {
            initialDelay = 0;
        }

        // Check fixed delay
        long fixedDelay = scheduled.fixedDelay();
        if (fixedDelay &gt;= 0) {
            Assert.isTrue(!processedSchedule, errorMessage);
            processedSchedule = true;
            this.registrar.addFixedDelayTask(new IntervalTask(runnable, fixedDelay, initialDelay));
        }
        String fixedDelayString = scheduled.fixedDelayString();
        if (StringUtils.hasText(fixedDelayString)) {
            Assert.isTrue(!processedSchedule, errorMessage);
            processedSchedule = true;
            if (this.embeddedValueResolver != null) {
                fixedDelayString = this.embeddedValueResolver.resolveStringValue(fixedDelayString);
            }
            try {
                fixedDelay = Integer.parseInt(fixedDelayString);
            }
            catch (NumberFormatException ex) {
                throw new IllegalArgumentException(
                        &quot;Invalid fixedDelayString value \&quot;&quot; + fixedDelayString + &quot;\&quot; - cannot parse into integer&quot;);
            }
            this.registrar.addFixedDelayTask(new IntervalTask(runnable, fixedDelay, initialDelay));
        }

        // Check fixed rate
        long fixedRate = scheduled.fixedRate();
        if (fixedRate &gt;= 0) {
            Assert.isTrue(!processedSchedule, errorMessage);
            processedSchedule = true;
            this.registrar.addFixedRateTask(new IntervalTask(runnable, fixedRate, initialDelay));
        }
        String fixedRateString = scheduled.fixedRateString();
        if (StringUtils.hasText(fixedRateString)) {
            Assert.isTrue(!processedSchedule, errorMessage);
            processedSchedule = true;
            if (this.embeddedValueResolver != null) {
                fixedRateString = this.embeddedValueResolver.resolveStringValue(fixedRateString);
            }
            try {
                fixedRate = Integer.parseInt(fixedRateString);
            }
            catch (NumberFormatException ex) {
                throw new IllegalArgumentException(
                        &quot;Invalid fixedRateString value \&quot;&quot; + fixedRateString + &quot;\&quot; - cannot parse into integer&quot;);
            }
            this.registrar.addFixedRateTask(new IntervalTask(runnable, fixedRate, initialDelay));
        }

        // Check whether we had any attribute set
        Assert.isTrue(processedSchedule, errorMessage);
    }
    catch (IllegalArgumentException ex) {
        throw new IllegalStateException(
                &quot;Encountered invalid @Scheduled method &apos;&quot; + method.getName() + &quot;&apos;: &quot; + ex.getMessage());
    }
}
</code></pre><p>这个方法有点儿长，但是思路很清晰:<br><img src="http://ou5y7q62a.bkt.clouddn.com/5.png" alt=""><br>从上面可以看出，定时任务最后被加入ScheduledTaskRegistrar中了，来看一下这个类：<br><img src="http://ou5y7q62a.bkt.clouddn.com/6.png" alt=""><br>这个类只是用来存放定时任务的（使用List来存储的）,其中的核心代码如下：<br><img src="http://ou5y7q62a.bkt.clouddn.com/7.png" alt=""><br>在ScheduledTaskRegistrar被实例化之后，调用afterPropertiesSet(),afterPropertiesSet()调用TaskScheduler的schedule方法并将返回结果放入set中。<br>看一下schedule方法：<br><img src="http://ou5y7q62a.bkt.clouddn.com/8.png" alt=""><br>到这里，我们大概了解了整个过程，所以说定时任务的执行最后是由一个继承了Delayed和Future的类定时执行的（ScheduledFuture），而且ScheduledFuture在容器中也是只会注册一次,一次定时也只会执行一次。<br>看来定时任务被执行两次的锅不是这个定时工具的问题（明显是我的思考方向出了问题，这个被广泛使用的东西应该不会出现这么严重的问题）。</p>
<p>于是,我去Spring的官网看了一下文档，其中有这么一段话引起了我的注意：<br><img src="http://ou5y7q62a.bkt.clouddn.com/9.png" alt=""><br>我的代码中没有使用@Configurable，但是我猜测可能是我使用定时注解的类被实例化两次造成的结果。<br>再看看代码，我使用annotation-driven和component-scan来注入Bean，那么来看一下IOC的具体过程。</p>
<p>首先来看一下Spring初始化的过程：</p>
<p> 一个Spring  MVC项目自然是通过DispactherServlet作为入口的，先看一下它的静态代码块：<br><img src="http://ou5y7q62a.bkt.clouddn.com/10.png" alt=""><br>这个没什么神奇的，就是加载配置文件而已，然后我们看一下DispatcherServlet的初始化代码：<br><img src="http://ou5y7q62a.bkt.clouddn.com/11.png" alt=""><br><img src="http://ou5y7q62a.bkt.clouddn.com/12.png" alt=""><br>使用了父类的构造函数，用来加载applicationContext,没什么好看的。<br>那我们看一看这个Servlet的init()方法：<br>好像没有。。那我们来看一下它父类FrameworkServlet的init():<br>也没有，那看一看FrameworkServlet的父类HttpServletBean的init()方法：<br><img src="http://ou5y7q62a.bkt.clouddn.com/13.png" alt=""><br>终于找到了，看注释可以知道，是由HttpServletBean的子类覆盖initServletBean()来做初始化工作的，<br>找一找，这个覆盖是由FrameworkServlet完成的,贴图太累了，上代码：</p>
<pre><code>@Override
protected final void initServletBean() throws ServletException {
    getServletContext().log(&quot;Initializing Spring FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);
    if (this.logger.isInfoEnabled()) {
        this.logger.info(&quot;FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;: initialization started&quot;);
    }
    long startTime = System.currentTimeMillis();

    try {
        this.webApplicationContext = initWebApplicationContext();
        initFrameworkServlet();
    }
    catch (ServletException ex) {
        this.logger.error(&quot;Context initialization failed&quot;, ex);
        throw ex;
    }
    catch (RuntimeException ex) {
        this.logger.error(&quot;Context initialization failed&quot;, ex);
        throw ex;
    }

    if (this.logger.isInfoEnabled()) {
        long elapsedTime = System.currentTimeMillis() - startTime;
        this.logger.info(&quot;FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;: initialization completed in &quot; +
                elapsedTime + &quot; ms&quot;);
    }
}
</code></pre><p>applicationContext是由initWebApplicationContext()方法完成加载：</p>
<pre><code>protected WebApplicationContext initWebApplicationContext() {
    WebApplicationContext rootContext =
            WebApplicationContextUtils.getWebApplicationContext(getServletContext());
    WebApplicationContext wac = null;

    if (this.webApplicationContext != null) {
        // A context instance was injected at construction time -&gt; use it
        wac = this.webApplicationContext;
        if (wac instanceof ConfigurableWebApplicationContext) {
            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
            if (!cwac.isActive()) {
                // The context has not yet been refreshed -&gt; provide services such as
                // setting the parent context, setting the application context id, etc
                if (cwac.getParent() == null) {
                    // The context instance was injected without an explicit parent -&gt; set
                    // the root application context (if any; may be null) as the parent
                    cwac.setParent(rootContext);
                }
                configureAndRefreshWebApplicationContext(cwac);
            }
        }
    }
    if (wac == null) {
        // No context instance was injected at construction time -&gt; see if one
        // has been registered in the servlet context. If one exists, it is assumed
        // that the parent context (if any) has already been set and that the
        // user has performed any initialization such as setting the context id
        wac = findWebApplicationContext();
    }
    if (wac == null) {
        // No context instance is defined for this servlet -&gt; create a local one
        wac = createWebApplicationContext(rootContext);
    }

    if (!this.refreshEventReceived) {
        // Either the context is not a ConfigurableApplicationContext with refresh
        // support or the context injected at construction time had already been
        // refreshed -&gt; trigger initial onRefresh manually here.
        onRefresh(wac);
    }

    if (this.publishContext) {
        // Publish the context as a servlet context attribute.
        String attrName = getServletContextAttributeName();
        getServletContext().setAttribute(attrName, wac);
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Published WebApplicationContext of servlet &apos;&quot; + getServletName() +
                    &quot;&apos; as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;);
        }
    }

    return wac;
}
</code></pre><p>通过断点调试，发现DispatcherServlet走的是无参的构造，所以wac为null：<br><img src="http://ou5y7q62a.bkt.clouddn.com/14.png" alt=""><br>进入findWebApplicationContext():<br><img src="http://ou5y7q62a.bkt.clouddn.com/15.png" alt=""><br>findWebApplicationContext()返回null：<br><img src="http://ou5y7q62a.bkt.clouddn.com/16.png" alt=""><br>进入createWebApplicationContext():<br><img src="http://ou5y7q62a.bkt.clouddn.com/17.png" alt=""><br>关键一步configureAndRefreshWebApplicationContext：<br><img src="http://ou5y7q62a.bkt.clouddn.com/18.png" alt=""><br>通过注释可以知道，其实initPropertySources()会在refresh()之后被调用，在这里调用一次只是为postProcessWebApplicationContext()做准备，其中refresh()实际上用于加载初始化bean(隐藏的好深。。)，进入refresh():<br><img src="http://ou5y7q62a.bkt.clouddn.com/19.png" alt=""><br>如果你进入prepareRefresh()就可以看到里面做了一次initPropertySources()动作来载入配置资源，但是我们现在关心的是bean的初始化，接着进入obtainFreshBeanFactory,其代码如下：</p>
<pre><code>/**
 * Tell the subclass to refresh the internal bean factory.
 * @return the fresh BeanFactory instance
 * @see #refreshBeanFactory()
 * @see #getBeanFactory()
 */
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    refreshBeanFactory();
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);
    }
    return beanFactory;
}
</code></pre><p>接着进入refreshBeanFactory()：<br><img src="http://ou5y7q62a.bkt.clouddn.com/20.png" alt=""><br>可以知道是在loadBeanDefinitions()中读取的配置文件，进去看看：<br><img src="http://ou5y7q62a.bkt.clouddn.com/21.png" alt=""><br>。。。。一层套一层，看来读取xml文件似乎是在initBeanDefinitionReader()和loadBeanDefinitions()里面完成的，进入initBeanDefinitionReader()一看什么都没有，那么loadBeanDefinitions()里面呢：<br><img src="http://ou5y7q62a.bkt.clouddn.com/22.png" alt=""><br>离读取文件越来越近了，看看reader.loadBeanDefinitions()都干了什么：<br>里面调用了内部的方法，最后是酱紫的：<br><img src="http://ou5y7q62a.bkt.clouddn.com/23.png" alt=""><br>尼玛。。又一个loadBeanDefinitions。。<br>反正最后读取xml文件的代码是下面这个：</p>
<pre><code>public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
    Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
    if (logger.isInfoEnabled()) {
        logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());
    }

    Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
    if (currentResources == null) {
        currentResources = new HashSet&lt;EncodedResource&gt;(4);
        this.resourcesCurrentlyBeingLoaded.set(currentResources);
    }
    if (!currentResources.add(encodedResource)) {
        throw new BeanDefinitionStoreException(
                &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);
    }
    try {
        InputStream inputStream = encodedResource.getResource().getInputStream();
        try {
            InputSource inputSource = new InputSource(inputStream);
            if (encodedResource.getEncoding() != null) {
                inputSource.setEncoding(encodedResource.getEncoding());
            }
            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
        }
        finally {
            inputStream.close();
        }
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(
                &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);
    }
    finally {
        currentResources.remove(encodedResource);
        if (currentResources.isEmpty()) {
            this.resourcesCurrentlyBeingLoaded.remove();
        }
    }
}
</code></pre><p>这样子的：</p>
<pre><code>protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
        throws BeanDefinitionStoreException {
    try {
        Document doc = doLoadDocument(inputSource, resource);
        return registerBeanDefinitions(doc, resource);
    }
    catch (BeanDefinitionStoreException ex) {
        throw ex;
    }
    catch (SAXParseException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
    }
    catch (SAXException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
    }
    catch (ParserConfigurationException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;Parser configuration exception parsing XML from &quot; + resource, ex);
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;IOException parsing XML document from &quot; + resource, ex);
    }
    catch (Throwable ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;Unexpected exception parsing XML document from &quot; + resource, ex);
    }
}
</code></pre><p>以及这样子的：</p>
<pre><code>protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception {
    return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,
            getValidationModeForResource(resource), isNamespaceAware());
}
</code></pre><p>还有这样子的：</p>
<pre><code>@Override
public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
        ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);
    }
    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
    return builder.parse(inputSource);
}
</code></pre><p>还有更多。。。。<br>反正最后就是通过流读取xml文件返回Document对象就是了（mdzz，就不应该放这些的源码。。。）,然后registerBeanDefinitions(),其中解析xml的关键一步在下面：</p>
<pre><code>protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    if (delegate.isDefaultNamespace(root)) {
        NodeList nl = root.getChildNodes();
        for (int i = 0; i &lt; nl.getLength(); i++) {
            Node node = nl.item(i);
            if (node instanceof Element) {
                Element ele = (Element) node;
                if (delegate.isDefaultNamespace(ele)) {
                    parseDefaultElement(ele, delegate);
                }
                else {
                    delegate.parseCustomElement(ele);
                }
            }
        }
    }
    else {
        delegate.parseCustomElement(root);
    }
}
</code></pre><p> delegate.parseCustomElement()用于解析spring自己的xml标签，关键的一个方法：</p>
<pre><code>@Override
public BeanDefinition parse(Element element, ParserContext parserContext) {
    return findParserForElement(element, parserContext).parse(element, parserContext);
}   
</code></pre><p>为对应的使用对象的parser,因为注入bean使用了component-scan，我们进入ComponentScanBeanDefinitionParser的parse()方法：</p>
<pre><code>@Override
public BeanDefinition parse(Element element, ParserContext parserContext) {
    String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE),
            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);

    // Actually scan for bean definitions and register them.
    ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);
    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);
    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);

    return null;
}
</code></pre><p>很容易知道scanner.doScan()这里执行了扫描并注入的动作:</p>
<pre><code>protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
    Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;();
    for (String basePackage : basePackages) {
        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
        for (BeanDefinition candidate : candidates) {
            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
            candidate.setScope(scopeMetadata.getScopeName());
            String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
            if (candidate instanceof AbstractBeanDefinition) {
                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
            }
            if (candidate instanceof AnnotatedBeanDefinition) {
                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
            }
            if (checkCandidate(beanName, candidate)) {
                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                beanDefinitions.add(definitionHolder);
                registerBeanDefinition(definitionHolder, this.registry);
            }
        }
    }
    return beanDefinitions;
}
</code></pre><p>现在我们又看见了一堆完全没有注释的代码了。。。<br>还好，我已经帮你找出findCandidateComponents()这个方法是包扫描的主要执行者，再进入看看：</p>
<pre><code>public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) {
    Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;();
    try {
        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
                resolveBasePackage(basePackage) + &quot;/&quot; + this.resourcePattern;
        Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
        boolean traceEnabled = logger.isTraceEnabled();
        boolean debugEnabled = logger.isDebugEnabled();
        for (Resource resource : resources) {
            if (traceEnabled) {
                logger.trace(&quot;Scanning &quot; + resource);
            }
            if (resource.isReadable()) {
                try {
                    MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
                    if (isCandidateComponent(metadataReader)) {
                        ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                        sbd.setResource(resource);
                        sbd.setSource(resource);
                        if (isCandidateComponent(sbd)) {
                            if (debugEnabled) {
                                logger.debug(&quot;Identified candidate component class: &quot; + resource);
                            }
                            candidates.add(sbd);
                        }
                        else {
                            if (debugEnabled) {
                                logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
                            }
                        }
                    }
                    else {
                        if (traceEnabled) {
                            logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
                        }
                    }
                }
                catch (Throwable ex) {
                    throw new BeanDefinitionStoreException(
                            &quot;Failed to read candidate component class: &quot; + resource, ex);
                }
            }
            else {
                if (traceEnabled) {
                    logger.trace(&quot;Ignored because not readable: &quot; + resource);
                }
            }
        }
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex);
    }
    return candidates;
}
</code></pre><p>这里面的关键又在于this.resourcePatternResolver.getResources(packageSearchPath),再深入,发现起作用的类是PathMatchingResourcePatternResolver，看看它的getResources()方法：</p>
<pre><code>@Override
public Resource[] getResources(String locationPattern) throws IOException {
    Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;);
    if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {
        // a class path resource (multiple resources for same name possible)
        if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
            // a class path resource pattern
            return findPathMatchingResources(locationPattern);
        }
        else {
            // all class path resources with the given name
            return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));
        }
    }
    else {
        // Only look for a pattern after a prefix here
        // (to not get fooled by a pattern symbol in a strange prefix).
        int prefixEnd = locationPattern.indexOf(&quot;:&quot;) + 1;
        if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {
            // a file pattern
            return findPathMatchingResources(locationPattern);
        }
        else {
            // a single resource with the given name
            return new Resource[] {getResourceLoader().getResource(locationPattern)};
        }
    }
}
</code></pre><p>这里我们又发现了findAllClassPathResources和findPathMatchingResources好像才是干活的那个：（这里只选了findAllClassPathResources，反正基本是一致的）</p>
<pre><code>protected Resource[] findAllClassPathResources(String location) throws IOException {
    String path = location;
    if (path.startsWith(&quot;/&quot;)) {
        path = path.substring(1);
    }
    Enumeration&lt;URL&gt; resourceUrls = getClassLoader().getResources(path);
    Set&lt;Resource&gt; result = new LinkedHashSet&lt;Resource&gt;(16);
    while (resourceUrls.hasMoreElements()) {
        URL url = resourceUrls.nextElement();
        result.add(convertClassLoaderURL(url));
    }
    return result.toArray(new Resource[result.size()]);
}
</code></pre><p>到这里，Spring IOC容器注入bean的原理基本浮出水面。（并没有。。好像只写了其中一部分吧）</p>
<h3 id="三、捋一下思路"><a href="#三、捋一下思路" class="headerlink" title="三、捋一下思路"></a>三、捋一下思路</h3><p>写到这里，我们整理一下思路：<br><br>（1）发现了一个问题：@Scheduled注解的方法被重复执行；<br>（2）@Scheduled注解及其后面的执行代码都没问题，问题应该在于bean被实例化两次；<br>（3）通过源码，我们发现bean实例化在xml文件中的入口是component-scan；<br>（4）我们又跟踪了一遍源码，源码没有问题；<br>（5）由（4）推出问题应该是在配置文件上面（因为我的代码不可能会导致这个问题）；<br>（6）看了配置文件，果然发现了问题：里面出现了两次component-scan(分别在spring mvc 和spring的配置文件里)，而且扫描的包名是同一个；<br>（7）回忆一下我们之前看的源码，无论是registerComponents()还是doScan()还是其之后加载类的方法，都没有做去重处理；<br>（8）也就是说，源头在于这个傻逼的配置文件（以前就有的，不关我事。。）扫描了两次包，从而导致的bean实例化两次，进而导致定时任务重复执行。</p>
<h3 id="四、解决方式"><a href="#四、解决方式" class="headerlink" title="四、解决方式"></a>四、解决方式</h3><p>好吧，我又被坑了？？？<br><br>解决倒是很简单，删掉其中一个context:component-scan，只留下一个扫描全部即。</p>
<p>嗯，就这样。不过好像有点不对啊，一个是Spring MVC的配置文件，另一个是Spring的配置文件，删掉可以吗，试一下看看，果然不行，因为我记得Spring MVC的IOC容器和Spring IOC容器并不是同一个（而且这个傻逼的web.xml文件同时配置了ContextLoaderListener和DispactherServlet。。。）,从上面的源码中可以知道可以存在多个ApplicationContext，而且Spring IOC容器应该会早于Spring MVC的（ContextLoaderListener先于DispactherServlet创建），两者是父子关系。</p>
<p>而且根据官方文档的说法，使用Spring MVC和Spring的时候只需要在web.xml中配置DispatcherServlet即可，<br>于是，我删掉了ContextLoaderListener的配置，发现果然定时任务恢复正常了。</p>
<p>或者，老一点版本的Spring好像必须配置ContextLoaderListener,此时的话，可以使用如下的方式配置：</p>
<pre><code>&lt;context:component-scan base-package=&quot;xxx.xxx.xxx&quot;&gt;  
   &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;  
&lt;/context:component-scan&gt;  

其中expression里面的就是你要排除的注解。
</code></pre><h3 id="五、最后还要说一下"><a href="#五、最后还要说一下" class="headerlink" title="五、最后还要说一下"></a>五、最后还要说一下</h3><p>其实一开始的时候，我就发现问题出在配置文件上面，只不过我对Spring的源码有一点好奇，就顺便跟踪源码走了一下，所以我在这里想说的是：Spring被这个项目的原作者用成这样真是（╯‵□′）╯︵┴─┴ </p>

  </section>

  
  
  

<!-- 注释掉这段以关闭评论  -->
<!-- <section class="post-comments">

	<div id="lv-container" data-id="city" data-uid="MTAyMC8yNzk0NC80NTIx">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
	</div>

</section> -->


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
