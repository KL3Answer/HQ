---
title: 2018年4中上旬面试总结
date: 2018-04-29 17:40:12
tags: 
	- 总结
---
简单记录一下最近面试中被问到的一些问题（都比较简单，所以就记的随意一些）

---
### 2018-03-30

* KMP
 

* HashMap 扩容 

      resize MAX_CAPACITY THRESHOLD loadfactor

* HashMap put 

      node treeNode (RBT) resize

* Collections copy (deep copy , shallow copy)

* google tesserart 

### 2018-04-02

* 网上商城如何减少MySQL压力

      Elasticsearch -> Redis -> MySQL

* cookie 

      domain 跨域  path

* jsonp 跨域 
        
      <script src="">  reponse: callback(data)

* mysql 

      主从复制 读写分离 mycat

* 同步代码块 

      double check 

*  线程安全容器 

       ConCurrentHashMap HashTable CopyOnWriteArrayList Vector Queue Deque  SynchronizedMap

* redis 数据类型 

      api String byte[] int double boolean （数据结构 KEY HASH LIST SET 
      SOREDSET）

* redis 单个key大小

       512MB

* 线程池饱和策略 
    
      ·AbortPolicy：直接抛出异常。
      ·CallerRunsPolicy：只用调用者所在线程来运行任务。
      ·DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
      ·DiscardPolicy：不处理，丢弃掉。

* InnoDB 索引 null值 

      无影响

* dubbo 异步发送 
    
      async sent Future Callback 事件通知

* dubbo 重试配置

      retries（默认三次？）

* rabbit MQ 分发策略

      依据 exchange 而定（direct、fanout、header、topic）

* CountDownLatch（countDown await） CyclicBarrier（await）

### 2018-04-08

* dubbo 通信协议 
     
      dubbo（Dubbo缺省协议采用单一长连接和NIO异步通讯）、thrift、http、rmi、redis等（具体之后再详解）

* rabbitMQ 消息丢失解决 

      RPC/mandatory + durable

* Tomcat 参数配置 

      server.xml: port context webapp workDir ; web.xml  context.xml

* @Transactional 

      AbstractPlatformTransactionManager
      TransactionAspectSupport
      method&class 回滚 RuntimeException and Error but not on CheckedException 
      rollbackFor noRollbackFor

### 2018-04-09

* spring @Async 
      spring schedule 线程池

* Spring Boot jar 方式启动
    
      META-INF MANIFEST  main-class >
      Laucher > createMainMethodRunner > SpringContext > refresh > createEmbeddedServletContainer 
      > tomcat start > StandardWarpper > StandardContext > ServletContextInitializer.onStartup

* Spring Boot tomcat 启动 

      Context容器和ContextConfig 
      > WEB-INF/lib目录下包含的jar包 的 META-INF/services javax.servlet.ServletContainerInitializer 
      > @HandlesTypes(WebApplicationInitializer.class) 
      -> ServletContainerInitializer.onStartup(WebApplicationInitializer.class) 
      -> WebApplicationInitializer.onStartup 
      -> WebApplicationInitializer.createRootApplicationContext 
      -> SpringBootStartApplication.configure 
      -> SpringApplication.run 
      -> createApplicationContext(Strategy method 通过一个简单的查找Servlet类的方式来判断是不是在web环境：如果是的话，
      则会创建AnnotationConfigEmbeddedWebApplicationContext，
      否则Spring context就是AnnotationConfigApplicationContext)

</br>

* Spring ContextLoaderLister 

      ContextLoaderListener static (load resource) 
      ContextLoaderListener.initWebApplicationContext
        ContextLoader.configureAndRefreshWebApplicationContext
            ConfigurableWebApplicationContext.refresh

* Spring DispatcherServlet 

      DispatcherServlet static (load resource) 
      HttpServletBean.init 
        FrameWorkServlet.initServletBean
            FrameWorkServlet.initWebApplicationContext
                FrameWorkServlet.createWebApplicationContext
                    BeanUtils.instantiateClass
                    FrameWorkServlet.configureAndRefreshWebApplicationContext
                DispatcherServlet.onRefresh
                    DispatcherServlet.initStrategies

* Spring MVC 

      DisplatcherServlet.doService 
        DisplatcherServlet.doDispatch
            DisplatcherServlet.getHandler
                HandlerMapping.getHandler
            DisplatcherServlet.getHandlerAdapter
                iterate 
                    if handlerAdapters.supports(handler)
				        return ha;
            if !mappedHandler.applyPreHandle(processedRequest, response))
                return;
            // Actually invoke the handler.
		    modelAndView = handlerAdapters.handle(processedRequest, response, mappedHandler.getHandler())
                handler.handleRequest
                    AbstractController.handleRequest
                        AbstractController.handleRequestInternal

            DisplatcherServlet.applyDefaultViewName(processedRequest, mv)
            mappedHandler.applyPostHandle(processedRequest, response, mv)                    
            DisplatcherServlet.processDispatchResult
                Resolver.resolveXXX

* Spring 插件机制

      FrameWorkServlet.initServletBean
        FrameWorkServlet.initWebApplicationContext
            XmlWebApplicationContext = FrameWorkServlet.createWebApplicationContext()
                new XmlBeanFactory
                    XmlBeanDefinitionReader.loadBeanDefinitions
                        XmlBeanDefinitionReader.doLoadBeanDefinitions 
                            XmlBeanDefinitionReader.registerBeanDefinitions(Document doc, Resource resource) 
                                DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(Document doc, XmlReaderContext readerContext) 
                                    DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions 
                                        DefaultBeanDefinitionDocumentReader.preProcessXml(root)
                                        DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)
                                            BeanDefinitionParserDelegate.parseCustomElement(Element ele, BeanDefinition containingBd)
                                                handler = NamespaceHandlerResolver.resolve(namespaceUri)
                                                    handler = handlerMappings.get(namespaceUri);
                                                    if handler is null{
                                                        ClassUtils.forName(namespaceUri)( from META-INF/spring.handlers)
                                                        NamespaceHandler.init
                                                        NamespaceHandlerSupport.registerBeanDefinitionParser
                                                        handlerMappings.put(namespaceUri, namespaceHandler) 
                                                    }
                                                handler.parse(ele, new ParserContext(this.readerContext, this, containingBd))
                                        DefaultBeanDefinitionDocumentReader.postProcessXml(root)
            FrameWorkServlet.configureAndRefreshWebApplicationContext
                ConfigurableApplicationContext.refresh

* Spring BeanDefinition Bean

      AbstractApplicationContext.refresh      
        AbstractApplicationContext.finishBeanFactoryInitialization
            BeanFactory.getBean
                AbstractBeanFactory.doGetBean
                    if mbd.isSingleton()
                        //get from memory or create and save 
                        DefaultSingletonRegistry.getSingeleton
                            DefaultSingletonRegistry.createBean
                    else if mbd.isPrototype()
                        //create
                        DefaultSingletonRegistry.beforePrototypeCreation
                        DefaultSingletonRegistry.createBean
                        DefaultSingletonRegistry.afterPrototypeCreation
                    else                     
                        //request and session Object , save in scope and get
                        DefaultSingletonRegistry.beforePrototypeCreation
                        DefaultSingletonRegistry.createBean
                        DefaultSingletonRegistry.afterPrototypeCreation

* JVM invokeDynamic

      占坑，之后再详细的写

* Spring BeanFactory ApplicationContext

      占坑，之后再详细的写

* MySQL 嵌套事务回滚

      占坑，之后再详细的写

### 2018-04-12

* Spring annotation-driven

      mvc:annotation-driven -> MVC JSON DefaultHandlerMapping DefaultHandlerAdapter
      tx-annotation-driven -> @Transactional 注解
      annotation-config -> 激活注解 via AnnotationConfigUtils.registerAnnotationConfigProcessors
      component-scan -> scan + annotation-config

* Tomcat

      占坑，之后再详细的写

* BlockingQueue 

      自旋+LockSupport park unpark , Reentrantlock  

* join 自旋   

      占坑，之后再详细的写         

* ThreadPoolExecutor 
      
      Worker addWorker(Thread.start) runWorker AQS

* Redis

      jedis.getResource 是长连接 ？

* zookeeper

      单一长连接 sesion 临时节点 以及其他的技术细节
            
* JWT
      
      Authentication: bearer Header.Payload(sub name exp iat iss aud).Signature   json

* shiro

      SecurityManager URL Filter   

### 2018-04-15

* MQ 消息的大小 

      可以设置

### 2018-04-15

* Spring 注入的时机

      refresh 时递归 getBean 注入

* Mybatis MapperScannerConfigurer postProcessBeanDefinitionRegistry doScan MapperFactoryBean      

### 2018-04-19

* RxJava

      Observer iterator fp

* Docker

      占坑，之后再详细的写

* Spring Boot 断路器

      占坑，之后再详细的写

* Java 分析工具 

      jvisual jstack （linux上还有 ps htop等）